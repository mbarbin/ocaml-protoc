[@@@ocaml.warning "-27-30-39"]

type person = {
  name : string;
  id : int32;
  email : string;
  phone : string list;
}
[@@deriving show { with_path = false }, eq, qcheck2]

type empty = unit
[@@deriving show { with_path = false }, eq, qcheck2]

type error = {
  error : string;
}
[@@deriving show { with_path = false }, eq, qcheck2]

type unit_or_error =
  | Unit
  | Error of error
[@@deriving show { with_path = false }, eq, qcheck2]

let rec default_person 
  ?name:((name:string) = "")
  ?id:((id:int32) = 0l)
  ?email:((email:string) = "")
  ?phone:((phone:string list) = [])
  () : person  = {
  name;
  id;
  email;
  phone;
}

let rec default_empty = ()

let rec default_error 
  ?error:((error:string) = "")
  () : error  = {
  error;
}

let rec default_unit_or_error (): unit_or_error = Unit

type person_mutable = {
  mutable name : string;
  mutable id : int32;
  mutable email : string;
  mutable phone : string list;
}

let default_person_mutable () : person_mutable = {
  name = "";
  id = 0l;
  email = "";
  phone = [];
}

type error_mutable = {
  mutable error : string;
}

let default_error_mutable () : error_mutable = {
  error = "";
}

[@@@ocaml.warning "-27-30-39"]

(** {2 Protobuf Encoding} *)

let rec encode_pb_person (v:person) encoder = 
  Pbrt.Encoder.string v.name encoder;
  Pbrt.Encoder.key 1 Pbrt.Bytes encoder; 
  Pbrt.Encoder.int32_as_varint v.id encoder;
  Pbrt.Encoder.key 2 Pbrt.Varint encoder; 
  Pbrt.Encoder.string v.email encoder;
  Pbrt.Encoder.key 3 Pbrt.Bytes encoder; 
  Pbrt.List_util.rev_iter_with (fun x encoder -> 
    Pbrt.Encoder.string x encoder;
    Pbrt.Encoder.key 4 Pbrt.Bytes encoder; 
  ) v.phone encoder;
  ()

let rec encode_pb_empty (v:empty) encoder = 
()

let rec encode_pb_error (v:error) encoder = 
  Pbrt.Encoder.string v.error encoder;
  Pbrt.Encoder.key 1 Pbrt.Bytes encoder; 
  ()

let rec encode_pb_unit_or_error (v:unit_or_error) encoder = 
  begin match v with
  | Unit ->
    Pbrt.Encoder.key 1 Pbrt.Bytes encoder; 
    Pbrt.Encoder.empty_nested encoder
  | Error x ->
    Pbrt.Encoder.nested encode_pb_error x encoder;
    Pbrt.Encoder.key 2 Pbrt.Bytes encoder; 
  end

[@@@ocaml.warning "-27-30-39"]

(** {2 Protobuf Decoding} *)

let rec decode_pb_person d =
  let v = default_person_mutable () in
  let continue__= ref true in
  while !continue__ do
    match Pbrt.Decoder.key d with
    | None -> (
      v.phone <- List.rev v.phone;
    ); continue__ := false
    | Some (1, Pbrt.Bytes) -> begin
      v.name <- Pbrt.Decoder.string d;
    end
    | Some (1, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(person), field(1)" pk
    | Some (2, Pbrt.Varint) -> begin
      v.id <- Pbrt.Decoder.int32_as_varint d;
    end
    | Some (2, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(person), field(2)" pk
    | Some (3, Pbrt.Bytes) -> begin
      v.email <- Pbrt.Decoder.string d;
    end
    | Some (3, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(person), field(3)" pk
    | Some (4, Pbrt.Bytes) -> begin
      v.phone <- (Pbrt.Decoder.string d) :: v.phone;
    end
    | Some (4, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(person), field(4)" pk
    | Some (_, payload_kind) -> Pbrt.Decoder.skip d payload_kind
  done;
  ({
    name = v.name;
    id = v.id;
    email = v.email;
    phone = v.phone;
  } : person)

let rec decode_pb_empty d =
  match Pbrt.Decoder.key d with
  | None -> ();
  | Some (_, pk) -> 
    Pbrt.Decoder.unexpected_payload "Unexpected fields in empty message(empty)" pk

let rec decode_pb_error d =
  let v = default_error_mutable () in
  let continue__= ref true in
  while !continue__ do
    match Pbrt.Decoder.key d with
    | None -> (
    ); continue__ := false
    | Some (1, Pbrt.Bytes) -> begin
      v.error <- Pbrt.Decoder.string d;
    end
    | Some (1, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(error), field(1)" pk
    | Some (_, payload_kind) -> Pbrt.Decoder.skip d payload_kind
  done;
  ({
    error = v.error;
  } : error)

let rec decode_pb_unit_or_error d = 
  let rec loop () = 
    let ret:unit_or_error = match Pbrt.Decoder.key d with
      | None -> Pbrt.Decoder.malformed_variant "unit_or_error"
      | Some (1, _) -> begin 
        Pbrt.Decoder.empty_nested d ;
        (Unit : unit_or_error)
      end
      | Some (2, _) -> (Error (decode_pb_error (Pbrt.Decoder.nested d)) : unit_or_error) 
      | Some (n, payload_kind) -> (
        Pbrt.Decoder.skip d payload_kind; 
        loop () 
      )
    in
    ret
  in
  loop ()

[@@@ocaml.warning "-27-30-39"]

(** {2 Protobuf YoJson Encoding} *)

let rec encode_json_person (v:person) = 
  let assoc = [] in 
  let assoc = ("name", Pbrt_yojson.make_string v.name) :: assoc in
  let assoc = ("id", Pbrt_yojson.make_int (Int32.to_int v.id)) :: assoc in
  let assoc = ("email", Pbrt_yojson.make_string v.email) :: assoc in
  let assoc =
    let l = v.phone |> List.map Pbrt_yojson.make_string in
    ("phone", `List l) :: assoc 
  in
  `Assoc assoc

let rec encode_json_empty (v:empty) = 
Pbrt_yojson.make_unit v

let rec encode_json_error (v:error) = 
  let assoc = [] in 
  let assoc = ("error", Pbrt_yojson.make_string v.error) :: assoc in
  `Assoc assoc

let rec encode_json_unit_or_error (v:unit_or_error) = 
  begin match v with
  | Unit -> `Assoc [("unit", `Null)]
  | Error v -> `Assoc [("error", encode_json_error v)]
  end

[@@@ocaml.warning "-27-30-39"]

(** {2 JSON Decoding} *)

let rec decode_json_person d =
  let v = default_person_mutable () in
  let assoc = match d with
    | `Assoc assoc -> assoc
    | _ -> assert(false)
  in
  List.iter (function 
    | ("name", json_value) -> 
      v.name <- Pbrt_yojson.string json_value "person" "name"
    | ("id", json_value) -> 
      v.id <- Pbrt_yojson.int32 json_value "person" "id"
    | ("email", json_value) -> 
      v.email <- Pbrt_yojson.string json_value "person" "email"
    | ("phone", `List l) -> begin
      v.phone <- List.map (function
        | json_value -> Pbrt_yojson.string json_value "person" "phone"
      ) l;
    end
    
    | (_, _) -> () (*Unknown fields are ignored*)
  ) assoc;
  ({
    name = v.name;
    id = v.id;
    email = v.email;
    phone = v.phone;
  } : person)

let rec decode_json_empty d =
Pbrt_yojson.unit d "empty" "empty record"

let rec decode_json_error d =
  let v = default_error_mutable () in
  let assoc = match d with
    | `Assoc assoc -> assoc
    | _ -> assert(false)
  in
  List.iter (function 
    | ("error", json_value) -> 
      v.error <- Pbrt_yojson.string json_value "error" "error"
    
    | (_, _) -> () (*Unknown fields are ignored*)
  ) assoc;
  ({
    error = v.error;
  } : error)

let rec decode_json_unit_or_error json =
  let assoc = match json with
    | `Assoc assoc -> assoc
    | _ -> assert(false)
  in
  let rec loop = function
    | [] -> Pbrt_yojson.E.malformed_variant "unit_or_error"
    | ("unit", _)::_-> (Unit : unit_or_error)
    | ("error", json_value)::_ -> 
      (Error ((decode_json_error json_value)) : unit_or_error)
    
    | _ :: tl -> loop tl
  in
  loop assoc

[@@@ocaml.warning "-27-30-39"]

(** {2 QuickCheck} *)

let quickcheck_person =
  { Pbrt_quickcheck.Type_class.
    type_name = "person";
    pp = pp_person;
    gen = gen_person;
    equal = equal_person;
    encode_pb = encode_pb_person;
    decode_pb = decode_pb_person;
    encode_json = encode_json_person;
    decode_json = decode_json_person;
  }

let quickcheck_tests_person ?gen () =
  Pbrt_quickcheck.Test.make ?gen quickcheck_person

let quickcheck_empty =
  { Pbrt_quickcheck.Type_class.
    type_name = "empty";
    pp = pp_empty;
    gen = gen_empty;
    equal = equal_empty;
    encode_pb = encode_pb_empty;
    decode_pb = decode_pb_empty;
    encode_json = encode_json_empty;
    decode_json = decode_json_empty;
  }

let quickcheck_tests_empty ?gen () =
  Pbrt_quickcheck.Test.make ?gen quickcheck_empty

let quickcheck_error =
  { Pbrt_quickcheck.Type_class.
    type_name = "error";
    pp = pp_error;
    gen = gen_error;
    equal = equal_error;
    encode_pb = encode_pb_error;
    decode_pb = decode_pb_error;
    encode_json = encode_json_error;
    decode_json = decode_json_error;
  }

let quickcheck_tests_error ?gen () =
  Pbrt_quickcheck.Test.make ?gen quickcheck_error

let quickcheck_unit_or_error =
  { Pbrt_quickcheck.Type_class.
    type_name = "unit_or_error";
    pp = pp_unit_or_error;
    gen = gen_unit_or_error;
    equal = equal_unit_or_error;
    encode_pb = encode_pb_unit_or_error;
    decode_pb = decode_pb_unit_or_error;
    encode_json = encode_json_unit_or_error;
    decode_json = decode_json_unit_or_error;
  }

let quickcheck_tests_unit_or_error ?gen () =
  Pbrt_quickcheck.Test.make ?gen quickcheck_unit_or_error

let all_quickcheck_tests
    ?(include_person = true)
    ?(include_empty = true)
    ?(include_error = true)
    ?(include_unit_or_error = true)
    () =
  List.flatten [
    if include_person then quickcheck_tests_person () else [];
    if include_empty then quickcheck_tests_empty () else [];
    if include_error then quickcheck_tests_error () else [];
    if include_unit_or_error then quickcheck_tests_unit_or_error () else [];
  ]